
class HuffmanNode:

    # Параметры конструктора объекта:
    #   key - ключ -> символ или последовательность символов, определяющих узел
    #   weight - вес (частота) узла

    def __init__(self, key: str, weight: int):
        self.root: HuffmanNode | None = None    # ссылка на корневой узел
        self.left: HuffmanNode | None = None    # ссылка на узел левой ветви
        self.right: HuffmanNode | None = None   # ссылка на узел правой ветви
        self.key = key
        self.weight = weight

    # По алгоритму потребуется выполнять слияние (объединение) двух узлов так, чтобы
    # появлялся новый узел, ссылающийся на оба узла как на левый (self) и правый (other).
    # А эти два узла должны ссылаться на него как на корневой.
    # Чтобы можно было выполнять слияние оператором "+", необходимо изменить
    # соответствующий дандер-метод.

    def __add__(self, other):
        # Проверка того, что объект other относится к классу HuffmanNode
        if isinstance(other, HuffmanNode):
            # При слиянии новый узел получает составной ключ и суммарный вес
            node = HuffmanNode(self.key + other.key, self.weight + other.weight)
            node.left = self
            node.right = other
            self.root = node
            other.root = node
            return node
        # Если other не относится к классу HuffmanNode, генерируем
        # соответствующую ошибку.
        raise TypeError(f'Unsupported type for addition: {type(other)}')

    # По алгоритму потребуется сортировать список узлов методом sort(). Чтобы он
    # мог сравнивать, какой узел из двух больше/меньше, необходимо изменить
    # только дандер-метод, соответствующий оператору "<".
    # По алгоритму необходимо, чтобы узлы сравнивались только по своим весам.

    def __lt__(self, other):
        # Проверка того, что объект other относится к классу HuffmanNode
        if isinstance(other, HuffmanNode):
            return self.weight < other.weight
        # Если other не относится к классу HuffmanNode, генерируем
        # соответствующую ошибку.
        raise TypeError(f'Unsupported type for comparison: {type(other)}')

    # Рекурсивный метод encode формирует префиксный код Хаффмана для узла.
    # В параметре code метод получает предшествующий код от своих ветвей.
    # Если узел относится к левой ветви своего корня, то к полученному коду
    # слева добавляется "0", если же узел относится к правой ветви своего корня,
    # то к полученному коду слева добавляется "1". Далее рекурсивно вызывается
    # encode() своего корня.

    def encode(self, code = '') -> str:
        if self.root is not None:
            if self is self.root.left:
                code = '0' + code
            elif self is self.root.right:
                code = '1' + code
            code = self.root.encode(code)
        return code

# Функция huffman_algorithm преобразует частотную таблицу (словарь frequencies)
# в кодовую таблицу - словарь, где ключами являются символы (буквы),
# а значениями - строковые представления кодов, где биты представлены символами
# "0" и "1".
# Необходимо помнить, что код Хаффмана - это битовый поток, а не поток байтов,
# символов или целых чисел.

def huffman_algorithm(frequencies: dict[str, int]) -> dict[str, str]:

    # Из полученной частотной таблицы формируем список листьев (узлов HuffmanNode).
    # Он потребуется на этапе построения кодовой таблицы. Пока листья еще не связаны
    # между собой.
    # Оператор "*" раскрывает кортеж item в параметры key, weight конструктора HuffmanNode.

    leaves = [HuffmanNode(*item) for item in frequencies.items()]

    # Этап 1. Построение бинарного дерева.

    # Формируем список корней roots как поверхностную копию списка leaves.
    # Таким образом, каждый узел оказывается и в списке leaves, и в списке roots.

    roots = list(leaves)

    # Цикл пока в списке корней больше 1 корня
    while len(roots) > 1:
        # сортируем список корней по возрастанию весов (частот)
        roots.sort()
        # добавляем в список корней результат слияния двух узлов с наименьшими весами
        roots.append(roots[0] + roots[1])
        # Соединенные узлы удаляем из списка корней. На каждой итерации список корней
        # сокращается: один узел добавили, два удалили.
        del roots[0:2]
    # По окончанию цикла все узлы, и листья, в том числе, оказываются связанными
    # в бинарное дерево.

    # Этап 2. Построение кодовой таблицы

    # Для каждого листа вызываем его метод encode(), использующий связи листа с корнем
    # в бинарном дереве. Полученный код Хаффмана заносим в кодовую таблицу.

    return {leaf.key: leaf.encode() for leaf in leaves}
