# Подвиг 5. На вход программе подается строка со словами, записанными через пробел. Необходимо прочитать эту строку и с помощью генераторов множеств и словарей сформировать словарь в формате:
#
# {слово_1: количество_1, слово_2: количество_2, ..., слово_N: количество_N}
#
# То есть, ключами выступают уникальные слова (без учета регистра), а значениями - число их встречаемости в тексте. На экран вывести значение словаря для слова (союза) 'и'. Если такого ключа нет, то вывести 0.
#
# Тесты: https://github.com/selfedu-rus/test-python-base/tree/main/6/6.6.5
#
# Sample Input:
#
# И что сказать и что сказать и нечего и точка
# Sample Output:
#
# 4

lst_in = input().lower().split()
d = {value: lst_in.count(value) for value in set(lst_in)}
print(d.get('и', 0))

from time import time

# beg = time()
# for i in range(200000):
#
#     lst = '''Как видно из примера, присвоение по новому ключу расширяет словарь,
#     присвоение по существующему ключу перезаписывает его, а попытка извлечения
#     несуществующего ключа порождает исключение. Для избежания исключения есть
#     специальный метод (см. ниже), или можно перехватывать исключение. Что же
#     можно еще делать со словарями? Да то же самое, что и с другими объектами:
#     встроенные функции, ключевые слова (например, циклы for и while), а также
#     специальные методы словарей. Как видно из примера, присвоение по новому ключу расширяет словарь,
#     присвоение по существующему ключу перезаписывает его, а попытка извлечения
#     несуществующего ключа порождает исключение. Для избежания исключения есть
#     специальный метод (см. ниже), или можно перехватывать исключение. Что же
#     можно еще делать со словарями? Да то же самое, что и с другими объектами:
#     встроенные функции, ключевые слова (например, циклы for и while), а также
#     специальные методы словарей.
#     '''.lower().split()
#     test = {x: lst.count(x) for x in lst}
#
# end = time()
# print(end - beg)


# beg1 = time()
# for x in range(200000):
#
#     lst = '''Как видно из примера, присвоение по новому ключу расширяет словарь,
#     присвоение по существующему ключу перезаписывает его, а попытка извлечения
#     несуществующего ключа порождает исключение. Для избежания исключения есть
#     специальный метод (см. ниже), или можно перехватывать исключение. Что же
#     можно еще делать со словарями? Да то же самое, что и с другими объектами:
#     встроенные функции, ключевые слова (например, циклы for и while), а также
#     специальные методы словарей. Как видно из примера, присвоение по новому ключу расширяет словарь,
#     присвоение по существующему ключу перезаписывает его, а попытка извлечения
#     несуществующего ключа порождает исключение. Для избежания исключения есть
#     специальный метод (см. ниже), или можно перехватывать исключение. Что же
#     можно еще делать со словарями? Да то же самое, что и с другими объектами:
#     встроенные функции, ключевые слова (например, циклы for и while), а также
#     специальные методы словарей.
#     '''.lower().split()
#     test = {x: lst.count(x) for x in set(lst)}
#
# end1 = time()
# print(end1 - beg1)